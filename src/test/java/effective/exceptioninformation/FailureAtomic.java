package effective.exceptioninformation;

public class FailureAtomic {
    /*
    * 努力使失败保持原子性
    * 当对象抛出异常后，通常我们期望这个对象仍然爆出在一中定义良好的可用状态中
    * 即使失败是发生在执行某个操作的过程中。
    * 对于受检的异常而言，这个尤为重要。
    * 因为调用者期望能从这种异常中进行恢复。一般而言，失败的方法调用应该使对象
    * 保持在被调用之前的状态。
    *
    * 几种途径
    * 1。 使用不可变对象，
    * 如果对象不可变，失败的原子性就是显然的，如果一个操作失败了，它可能会组织创建新的
    * 对象，但是永远也不会使已有对象保持在不一致的状态之中。因为当每个对象被创建之后它就
    * 处于一致的状态中，以后也不会有任何变化
    *
    * 2。执行之前检查参数有效性
    * 可以在对象被修改
    *
    * 3.编写一段恢复代码，recovery code,由它来拦截操作过程中发生的失败，以及使对象回滚到操作之前的
    * 状态，这种办法主要用于永久性数据结构
    *
    * 4。对对象的一个临时拷贝进行操作。当操作完成之后，用临时拷贝中的结果
    * 代替对象的内容。如果数据保存在临时的数据结构中，计算过程会更加快，使用
    * 这种方法就是见很自然的事情。
    *
    * */

}
